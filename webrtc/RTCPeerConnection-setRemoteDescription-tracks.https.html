<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.setRemoteDescription - add/remove remote tracks</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
  'use strict';

  // Test is based on the following editor draft:
  // https://w3c.github.io/webrtc-pc/archives/20171002/webrtc.html

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //   expectCalled
  //   getUserMediaTracksAndStreams
  //   performOffer
  //   Resolver

  // These tests are concerned with the observable consequences of processing
  // the addition or removal of remote tracks, including events firing and the
  // states of RTCPeerConnection, MediaStream and MediaStreamTrack.

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      let localTrack = tracks[0];
      caller.addTrack(localTrack);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        let remoteTrack = trackEvent.track;
        assert_equals(remoteTrack.id, localTrack.id,
                      'Expected local and remote track IDs to match.');
        assert_equals(trackEvent.streams.length, 0,
                      'Expected remote track not to belong to a stream.');
        t.done();
      }, 1000, 'Expected callee.ontrack to fire but it timed out.');
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() with a track and no stream makes ontrack fire with a track and no stream.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      let localTrack = tracks[0];
      let localStream = streams[0];
      caller.addTrack(localTrack, localStream);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        assert_equals(trackEvent.streams.length, 1,
                      'Expected track event to fire with a single stream.');
        let remoteTrack = trackEvent.track;
        let remoteStream = trackEvent.streams[0];
        assert_equals(remoteTrack.id, localTrack.id,
                      'Expected local and remote track IDs to match.');
        assert_equals(remoteStream.id, localStream.id,
                      'Expected local and remote stream IDs to match.');
        assert_array_equals(remoteStream.getTracks(), [remoteTrack],
                            'Expected the remote stream\'s tracks to be the remote track.');
        t.done();
      }, 1000, 'Expected callee.ontrack to fire but it timed out.');
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() with a track and a stream makes ontrack fire with a track and a stream.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(2)
    .then(expectCalled(t, ([tracks, streams]) => {
      let localTrack1 = tracks[0];
      let localTrack2 = tracks[1];
      let localStream = streams[0];
      caller.addTrack(localTrack1, localStream);
      caller.addTrack(localTrack2, localStream);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        assert_equals(trackEvent.streams.length, 1,
                      'Expected track event to fire with a single stream.');
        let remoteTrack1 = trackEvent.track;
        let remoteStream = trackEvent.streams[0];
        assert_equals(remoteTrack1.id, localTrack1.id,
                      'Expected first remote track ID to match first local track ID.');
        assert_equals(remoteStream.getTracks().length, 2,
                      'Expected the remote stream to contain two tracks.');
        callee.ontrack = expectCalled(t, trackEvent => {
          assert_equals(trackEvent.streams.length, 1,
                        'Expected track event to fire with a single stream.');
          let remoteTrack2 = trackEvent.track;
          assert_equals(trackEvent.streams[0], remoteStream,
                        'Expected both track events to fire with the same remote stream.');
          assert_equals(remoteTrack2.id, localTrack2.id,
                        'Expected second remote track ID to match second local track ID.');
          assert_equals(remoteStream.getTracks().length, 2,
                        'Expected the remote stream to contain two tracks.');
          assert_array_equals(remoteStream.getTracks(), [remoteTrack1, remoteTrack2],
                              'Expected the remote stream\'s tracks to be the [first, second] remote tracks.');
          t.done();
        }, 1000, 'Expected callee.ontrack to be called a second time but timed out.');
      }, 1000, 'Expected callee.ontrack to fire but it timed out.');
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() with two tracks and one stream makes ontrack fire twice with the tracks and shared stream.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(2)
    .then(expectCalled(t, ([tracks, streams]) => {
      let localTrack = tracks[0];
      let localStreams = streams;
      caller.addTrack(localTrack, localStreams[0], localStreams[1]);
      let performOffer = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        assert_equals(trackEvent.streams.length, 2,
                      'Expected the track event to fire with two streams.');
        let remoteTrack = trackEvent.track;
        let remoteStreams = trackEvent.streams;
        assert_equals(remoteTrack.id, localTrack.id,
                      'Expected local and remote track IDs to match.');
        assert_equals(remoteStreams[0].id, localStreams[0].id,
                      'Expected the first remote stream ID to match the first local stream ID.');
        assert_equals(remoteStreams[1].id, localStreams[1].id,
                      'Expected the second remote stream ID to match the second local stream ID.');
        assert_array_equals(remoteStreams[0].getTracks(), [remoteTrack],
                            'Expected the remote stream\'s tracks to be the remote track.');
        assert_array_equals(remoteStreams[1].getTracks(), [remoteTrack],
                            'Expected the remote stream\'s tracks to be the remote track.');
        t.done();
      }, 1000, 'Expected callee.ontrack to fire but it timed out.');
      return performOffer;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() with a track and two streams makes ontrack fire with a track and two streams.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let eventSequence = '';
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      caller.addTrack(tracks[0]);
      let ontrackResolver = new Resolver();
      callee.ontrack = () => {
        eventSequence += 'ontrack;';
        ontrackResolver.resolve();
      }
      return Promise.all([
        ontrackResolver.promise,
        performOffer(caller, callee).then(() => {
          eventSequence += 'setRemoteDescription;';
        })
      ]);
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .then(expectCalled(t, () => {
      assert_equals(eventSequence, 'ontrack;setRemoteDescription;');
      t.done();
    }, 1000, 'Expected ontrack to fire and performOffer()\'s promise to resolve but timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'ontrack fires before setRemoteDescription resolves.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      caller.addTrack(tracks[0]);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        assert_array_equals(callee.getReceivers(), [trackEvent.receiver]);
        t.done();
      }, 1000, 'Expected callee.ontrack to fire but it timed out.');
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'ontrack\'s receiver matches getReceivers().');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      let sender = caller.addTrack(tracks[0]);
      assert_true(sender != null);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        let receivers = callee.getReceivers();
        assert_equals(receivers.length, 1,
                      'Expected getReceivers() to be the track event\'s receiver.');
        caller.removeTrack(sender);
        performOffer(caller, callee)
        .then(expectCalled(t, () => {
          assert_array_equals(callee.getReceivers(), receivers,
                              'Expected the set of receivers to remain the same.');
          t.done();
        }, 1000, 'Expected performOffer()\'s promise to resolve but it timed out.'));
      }, 1000, 'Expected callee.ontrack to fire but it timed out.');
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'removeTrack() does not remove the receiver.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      let sender = caller.addTrack(tracks[0], streams[0]);
      assert_true(sender != null);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        assert_not_equals(trackEvent.track, null);
        assert_equals(trackEvent.streams.length, 1);
        assert_true(trackEvent.streams[0].getTracks().includes(trackEvent.track));
        caller.removeTrack(sender);
        performOffer(caller, callee);
        trackEvent.streams[0].onremovetrack = expectCalled(t, removeEvent => {
          assert_equals(removeEvent.track, trackEvent.track);
          assert_false(trackEvent.streams[0].getTracks().includes(trackEvent.track));
          t.done();
        }, 1000, 'Expected stream\'s onremovetrack to fire but it timed out.');
      }), 1000, 'Expected callee.ontrack to fire but it timed out.';
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'removeTrack() causes onremovetrack and the track to be removed from the stream.');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    return getUserMediaTracksAndStreams(1)
    .then(expectCalled(t, ([tracks, streams]) => {
      let sender = caller.addTrack(tracks[0]);
      assert_true(sender != null);
      let offerPromise = performOffer(caller, callee);
      callee.ontrack = expectCalled(t, trackEvent => {
        assert_not_equals(trackEvent.track, null);
        caller.removeTrack(sender);
        performOffer(caller, callee);
        trackEvent.track.onmute = expectCalled(t, () => {
          assert_true(trackEvent.track.muted);
          t.done();
        }, 1000, 'Expected track\'s onmute to fire but it timed out.');
      }), 1000, 'Expected callee.ontrack to fire but it timed out.';
      return offerPromise;
    }, 1000, 'Expected getUserMediaTracksAndStreams()\'s promise to resolve but it timed out.'))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'removeTrack() causes onmute and the track to be muted.');

</script>
